<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Portfolio Backtester v5.4.8</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  <style>
    :root {
      --primary-color: #007aff; --primary-hover: #005ecb; --border-color: #dee2e6;
      --background-main: #f0f2f5; --background-card: #ffffff; --text-color: #212529; 
      --text-light: #6c757d; --error-color: #d93025; --green: #34c759; --red: #ff3b30;
    }
    html { scroll-behavior: smooth; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background-color: var(--background-main); color: var(--text-color); margin: 0; padding: 0 0 40px 0;
    }
    .app-container { max-width: 1200px; margin: 0 auto; padding: 10px; }
    h1, h2, h3 { color: var(--text-color); }
    h1 { font-size: 26px; margin-bottom: 5px; text-align: center; }
    h2 { font-size: 20px; margin-top: 25px; border-bottom: 1px solid var(--border-color); padding-bottom: 8px; }
    h3 { font-size: 18px; margin-bottom: 15px; }
    .version { font-size: 14px; color: var(--text-light); margin-top: 0; margin-bottom: 20px; text-align: center; }
    .section-card {
      background: var(--background-card); border-radius: 10px; padding: 20px;
      margin-bottom: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.07);
    }
    .controls-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 18px; }
    .control-group { display: flex; flex-direction: column; gap: 6px; }
    .control-group label { font-weight: 600; font-size: 14px; display: flex; align-items: center; gap: 6px; }

    .app-container input[type="text"],
    .app-container input[type="number"],
    .app-container input[type="date"],
    .app-container select {
        width: 100%; box-sizing: border-box; 
    }

    .control-group input, .control-group select {
      font-size: 15px; padding: 10px; border-radius: 6px; border: 1px solid var(--border-color);
    }

    .phase-header {
        font-size: 16px; font-weight: 600; margin-top: 20px; margin-bottom: 15px;
        padding-bottom: 8px; border-bottom: 1px solid #e9ecef;
    }
    .indented-settings {
        margin-top: 15px; margin-left: 20px; padding-left: 15px; border-left: 3px solid #e9ecef;
    }

    .help-icon {
        display: flex; align-items: center; justify-content: center;
        width: 18px; height: 18px; border-radius: 50%; background-color: #e9ecef;
        color: #6c757d; font-size: 11px; font-weight: bold;
        cursor: help; user-select: none; flex-shrink: 0;
    }
    
    #master-tooltip {
        visibility: hidden; opacity: 0; transition: opacity 0.2s, visibility 0.2s;
        position: fixed;
        width: 260px; background-color: #343a40; color: #fff;
        text-align: left; border-radius: 6px; padding: 10px;
        z-index: 1000; pointer-events: none;
        font-size: 13px; font-weight: 400; line-height: 1.5;
    }

    #portfolios-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px; }
    .portfolio-card { border: 1px solid transparent; border-radius: 8px; padding: 15px; background: #f8f9fa; }
    .portfolio-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
    .portfolio-header input[type="text"] { font-size: 18px; font-weight: bold; border: none; background: transparent; padding: 5px; width: 70%; }
    .remove-portfolio-btn { background: #e9ecef; color: var(--text-light); border: none; border-radius: 6px; padding: 5px 8px; cursor: pointer; font-size: 12px; font-weight: 600; }
    .ticker-input-row { display: flex; flex-wrap: nowrap; gap: 8px; margin-bottom: 8px; align-items: center; }
    .ticker-input-row input { text-transform: uppercase; padding: 8px; border: 1px solid var(--border-color); border-radius: 6px; font-size: 14px; }
    .remove-ticker-btn { background: var(--red); color: white; border: none; border-radius: 50%; width: 26px; height: 26px; cursor: pointer; font-size: 14px; line-height: 26px; text-align: center; }
    .add-btn { background: var(--primary-color); color: white; border: none; border-radius: 8px; padding: 10px 15px; cursor: pointer; font-weight: 500; }
    
    .run-button-container { display: flex; justify-content: center; align-items: center; gap: 15px; margin-top: 20px; }
    #run-backtest-btn { font-size: 16px; padding: 12px 30px; }
    #run-backtest-btn:disabled { background-color: #a0c3ff; cursor: not-allowed; }

    .projections-button-wrapper { display: flex; justify-content: center; margin-top: 25px; }
    
    .outcome-explanation {
        font-size: 12px; color: var(--text-light); font-weight: 400;
        display: block; margin-top: 2px; line-height: 1.3;
    }
    
    #debug-container {
      background-color: #fffbe6; border: 1px solid #ff9500; border-radius: 8px;
      margin-top: 20px; padding: 15px; font-family: monospace; font-size: 13px;
      color: #8a6d3b; max-height: 200px; overflow-y: auto; white-space: pre-wrap;
    }
    #debug-container h4 { margin-top: 0; color: #66512c; }

    .loader { display: none; width: 24px; height: 24px; border: 3px solid var(--primary-color); border-bottom-color: transparent; border-radius: 50%; animation: rotation 1s linear infinite; }
    @keyframes rotation { 0% { transform: rotate(360deg); } 100% { transform: rotate(0deg); } }
    #error-container { color: var(--error-color); text-align: center; font-weight: bold; margin: 15px auto; max-width: 600px; }
    .table-container { overflow-x: auto; -webkit-overflow-scrolling: touch; }
    table { border-collapse: collapse; width: 100%; margin-bottom: 25px; }
    th, td { border: 1px solid var(--border-color); padding: 10px 12px; text-align: right; font-size: 14px; white-space: nowrap; vertical-align: top; }
    th { background: #e9ecef; font-weight: 600; text-align: center; }
    td:first-child, th:first-child { text-align: left; font-weight: bold; white-space: normal; }
    .positive { color: #1e7e34; } .negative { color: var(--red); }
    .hidden { display: none; }
    
    /* MOBILE UI FIX v5.4.8 */
    @media (max-width: 768px) {
      .app-container { padding: 5px; } .section-card { padding: 15px; }
      h1 { font-size: 24px; } h2 { font-size: 20px; }

      /* This rule now ONLY applies to the Setup section for a clean 2-column layout */
      #setup-card .controls-grid {
          grid-template-columns: 1fr 1fr;
          gap: 12px;
      }

      /* This new rule forces the retirement grids into a single, logical column */
      #retire-settings .controls-grid {
          grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div id="master-tooltip"></div>
  <div class="app-container">
    <h1>Portfolio Backtester</h1>
    <p class="version">Version 5.4.8</p> 
    <!-- UI FIX v5.4.8: Added ID to the setup card for specific CSS targeting -->
    <div id="setup-card" class="section-card">
      <h2>1. Setup</h2>
      <div class="controls-grid">
        <div class="control-group"><label for="start-date">Start Date</label><input type="date" id="start-date" value="2018-01-01"></div>
        <div class="control-group"><label for="end-date">End Date</label><input type="date" id="end-date" value="2023-12-31"></div>
        <div class="control-group"><label for="initial-investment">Initial Investment ($)</label><input type="number" id="initial-investment" value="10000"></div>
        <div class="control-group"><label for="contribution-amount">Contribution Amount ($)</label><input type="number" id="contribution-amount" value="500"></div>
        <div class="control-group"><label for="contribution-frequency">Contribution Frequency</label><select id="contribution-frequency"><option value="monthly">Monthly</option><option value="quarterly">Quarterly</option><option value="annually">Annually</option><option value="none">None</option></select></div>
        <div class="control-group"><label for="rebalance-frequency">Rebalance Frequency</label><select id="rebalance-frequency"><option value="annually">Annually</option><option value="quarterly">Quarterly</option><option value="never">Never</option></select></div>
        <div class="control-group"><label for="reinvest-dividends">Reinvest Dividends?</label><select id="reinvest-dividends"><option value="true">True</option><option value="false">False</option></select></div>
        <div class="control-group"><label for="risk-free-rate">Risk-Free Rate (%)
            <span class="help-icon" data-tooltip="The return of a 'risk-free' investment, like a government bond. Used to calculate risk-adjusted return metrics like the Sharpe Ratio.">?</span>
        </label><input type="number" id="risk-free-rate" value="1.5"></div>
        <div class="control-group"><label for="dividend-tax-rate">Dividend Tax Rate (%)</label><input type="number" id="dividend-tax-rate" value="15"></div>
        <div class="control-group"><label for="gains-tax-rate">Capital Gains Tax (%)</label><input type="number" id="gains-tax-rate" value="15"></div>
        <div class="control-group"><label for="benchmark1">Benchmark 1</label><input type="text" id="benchmark1" value="SPY"></div>
        <div class="control-group"><label for="benchmark2">Benchmark 2</label><input type="text" id="benchmark2" value="QQQ"></div>
      </div>
    </div>
    <div class="section-card">
        <h2>2. Configure Portfolios</h2>
        <div id="portfolios-container"></div>
        <button id="add-portfolio-btn" class="add-btn" style="margin-top: 15px;">+ Add Portfolio</button>
    </div>
    
    <div class="run-button-container">
        <button id="run-backtest-btn" class="add-btn">Run Backtest</button>
        <div id="loader" class="loader"></div>
    </div>
    <div id="error-container"></div>
    <div id="results-area" class="section-card hidden" style="padding-top: 5px;"></div>
    
    <div id="projections-area" class="section-card hidden">
        <h2>4. Future Projections</h2>
        
        <div class="control-group" style="margin-bottom: 20px;">
            <label for="projection-goal">What is your goal for this projection?
                 <span class="help-icon" data-tooltip="Choose whether you want to see a simple projection of your savings growth or a more detailed retirement plan with an income phase.">?</span>
            </label>
            <select id="projection-goal">
                <option value="grow" selected>Continue saving and grow my portfolio</option>
                <option value="retire">Plan for a future retirement income</option>
            </select>
        </div>

        <div id="grow-settings">
            <div class="controls-grid">
                <div class="control-group"><label for="grow-projection-period">Projection Period (Years)</label><input type="number" id="grow-projection-period" value="10"></div>
                <div class="control-group"><label for="grow-sim-quality">Simulation Quality
                    <span class="help-icon" data-tooltip="The number of possible future scenarios we will test. 'Recommended' offers a good balance of speed and accuracy.">?</span>
                </label><select id="grow-sim-quality"><option value="1000">Fast</option><option value="5000" selected>Recommended</option><option value="10000">High Precision</option></select></div>
                <div class="control-group"><label for="grow-inflation-rate">Assumed Annual Inflation (%)
                     <span class="help-icon" data-tooltip="The long-term average inflation rate you expect. This helps calculate the 'real' value of your money in the future (its purchasing power).">?</span>
                </label><input type="number" id="grow-inflation-rate" value="3.0"></div>
                <div class="control-group"><label for="grow-contribution-increase">Annual Contribution Increase (%)
                     <span class="help-icon" data-tooltip="The percentage by which you plan to increase your yearly contributions. This is useful for modeling raises or saving more over time.">?</span>
                </label><input type="number" id="grow-contribution-increase" value="2.0"></div>
            </div>
        </div>

        <div id="retire-settings" class="hidden">
            <div class="control-group" style="margin-bottom: 20px;">
                <label for="current-age">What is your current age?</label>
                <input type="number" id="current-age" value="35">
            </div>
            
            <div class="phase-header">Phase 1: Your Working Years (Saving)</div>
            <div class="controls-grid">
                 <div class="control-group"><label for="retirement-age">At what age do you want to retire?</label><input type="number" id="retirement-age" value="65"></div>
                 <div class="control-group"><label for="retire-contribution-increase">Annual Saving Increase (%)
                     <span class="help-icon" data-tooltip="The percentage by which you plan to increase your yearly contributions during the 'Saving & Growth' phase.">?</span>
                 </label><input type="number" id="retire-contribution-increase" value="2.0"></div>
            </div>

            <div class="phase-header">Phase 2: Your Retirement Years (Income)</div>
            <div class="controls-grid">
                <div class="control-group">
                    <label for="withdrawal-strategy">What is your retirement income plan?
                        <span class="help-icon" data-tooltip="Choose how you want to receive your income in retirement. This determines how money is withdrawn from your portfolio.">?</span>
                    </label>
                    <select id="withdrawal-strategy">
                        <option value="dividends">Live Off Dividend Income Only</option>
                        <option value="fixed_amount" selected>Withdraw a Fixed Amount Annually</option>
                        <option value="percentage">Withdraw a Percentage Annually</option>
                    </select>
                </div>
                <div class="control-group"><label for="final-age">How long should income last (until age...)?
                     <span class="help-icon" data-tooltip="The age until which you need your retirement income to last.">?</span>
                </label><input type="number" id="final-age" value="95"></div>
            </div>
            <div class="indented-settings">
                <div class="control-group hidden" id="fixed_amount_setting"><label for="annual-withdrawal-amount">Annual Withdrawal Amount ($)</label><input type="number" id="annual-withdrawal-amount" value="50000"></div>
                <div class="control-group hidden" id="percentage_setting"><label for="annual-withdrawal-rate">Annual Withdrawal Rate (%)</label><input type="number" id="annual-withdrawal-rate" value="4"></div>
            </div>
            
             <div class="control-group" style="margin-top:20px;">
                <label for="retire-inflation-rate">Assumed Annual Inflation (%)
                     <span class="help-icon" data-tooltip="The long-term average inflation rate you expect. This helps calculate the 'real' value of your money in the future (its purchasing power).">?</span>
                </label>
                <input type="number" id="retire-inflation-rate" value="3.0">
            </div>
        </div>

        <div class="projections-button-wrapper"><button id="run-projections-btn" class="add-btn">Run Projections</button></div>
        <div id="debug-container" class="hidden"><h4>Projection Debug Log:</h4></div>
        
        <div id="projections-results-area" class="hidden" style="margin-top: 20px;"></div>
        <div id="projection-chart-container" class="hidden">
            <div style="width: 100%; max-width: 900px; margin: auto; padding-bottom: 20px;">
                <canvas id="projection-chart"></canvas>
            </div>
        </div>
    </div>
  </div>

<script>
document.addEventListener("DOMContentLoaded", () => {
    let historicalResults = [];
    let projectionChartInstance = null;
    let primaryBenchmarkTicker = 'SPY';

    const runBtn = document.getElementById('run-backtest-btn');
    const loader = document.getElementById('loader');
    const errorContainer = document.getElementById('error-container');
    const resultsArea = document.getElementById('results-area');
    const portfoliosContainer = document.getElementById('portfolios-container');
    const addPortfolioBtn = document.getElementById('add-portfolio-btn');
    let portfolioCount = 0;

    const projectionsArea = document.getElementById('projections-area');
    const projectionsResultsArea = document.getElementById('projections-results-area');
    const projectionChartContainer = document.getElementById('projection-chart-container');
    const runProjectionsBtn = document.getElementById('run-projections-btn');
    const debugContainer = document.getElementById('debug-container');
    const projectionGoalSelect = document.getElementById('projection-goal');
    const growSettings = document.getElementById('grow-settings');
    const retireSettings = document.getElementById('retire-settings');
    const withdrawalStrategySelect = document.getElementById('withdrawal-strategy');
    const fixedAmountSetting = document.getElementById('fixed_amount_setting');
    const percentageSetting = document.getElementById('percentage_setting');
    const masterTooltip = document.getElementById('master-tooltip');
    
    document.addEventListener('mouseover', (e) => {
        if (e.target.classList.contains('help-icon')) {
            const tooltipText = e.target.dataset.tooltip; if (!tooltipText) return;
            masterTooltip.textContent = tooltipText;
            const iconRect = e.target.getBoundingClientRect();
            let top = iconRect.top - masterTooltip.offsetHeight - 8;
            let left = iconRect.left + (iconRect.width / 2) - (masterTooltip.offsetWidth / 2);
            if (top < 0) { top = iconRect.bottom + 8; }
            if (left < 10) left = 10;
            if (left + masterTooltip.offsetWidth > window.innerWidth - 10) { left = window.innerWidth - masterTooltip.offsetWidth - 10; }
            masterTooltip.style.left = `${left}px`; masterTooltip.style.top = `${top}px`;
            masterTooltip.style.visibility = 'visible'; masterTooltip.style.opacity = '1';
        }
    });
    document.addEventListener('mouseout', (e) => {
        if (e.target.classList.contains('help-icon')) {
            masterTooltip.style.visibility = 'hidden';
            masterTooltip.style.opacity = '0';
        }
    });

    projectionGoalSelect.addEventListener('change', () => {
        const isRetire = projectionGoalSelect.value === 'retire';
        growSettings.classList.toggle('hidden', isRetire);
        retireSettings.classList.toggle('hidden', !isRetire);
        if (isRetire) { updateWithdrawalSettingsVisibility(); }
    });
    withdrawalStrategySelect.addEventListener('change', updateWithdrawalSettingsVisibility);

    function updateWithdrawalSettingsVisibility() {
        const strategy = withdrawalStrategySelect.value;
        fixedAmountSetting.classList.toggle('hidden', strategy !== 'fixed_amount');
        percentageSetting.classList.toggle('hidden', strategy !== 'percentage');
    }
    projectionGoalSelect.dispatchEvent(new Event('change'));
    
    function logToPage(message, isError = false) {
        debugContainer.classList.remove('hidden'); const p = document.createElement('p');
        p.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        if (isError) { p.style.color = 'var(--error-color)'; p.style.fontWeight = 'bold'; }
        debugContainer.appendChild(p); debugContainer.scrollTop = debugContainer.scrollHeight;
    }
    
    function addPortfolio() { portfolioCount++; const card = document.createElement('div'); card.className = 'portfolio-card'; card.id = `portfolio-${portfolioCount}`; card.innerHTML = `<div class="portfolio-header"><input type="text" value="Portfolio ${String.fromCharCode(64 + portfolioCount)}" class="portfolio-name-input"><button class="remove-portfolio-btn">&times;</button></div><div class="tickers-list"></div><button class="add-ticker-btn add-btn" style="font-size: 14px; padding: 8px 12px;">+ Add Ticker</button>`; portfoliosContainer.appendChild(card); card.querySelector('.add-ticker-btn').addEventListener('click', () => addTicker(card)); card.querySelector('.remove-portfolio-btn').addEventListener('click', () => card.remove()); if (portfolioCount === 1) { addTicker(card, 'VTI', '70'); addTicker(card, 'VXUS', '20'); addTicker(card, 'BND', '10'); } if (portfolioCount === 2) { addTicker(card, 'QQQ', '80'); addTicker(card, 'SCHD', '20'); } }
    function addTicker(portfolioCard, ticker = '', allocation = '') { const tickersList = portfolioCard.querySelector('.tickers-list'); const row = document.createElement('div'); row.className = 'ticker-input-row'; row.innerHTML = `<div class="ticker-symbol"><input type="text" placeholder="Ticker" class="ticker-input" value="${ticker}"></div><div class="ticker-alloc"><input type="number" placeholder="Alloc." class="allocation-input" value="${allocation}"></div><span>%</span><button class="remove-ticker-btn">&times;</button>`; tickersList.appendChild(row); row.querySelector('.remove-ticker-btn').addEventListener('click', () => row.remove()); }
    function parsePortfolios() { const portfolios = []; const portfolioCards = document.querySelectorAll('.portfolio-card'); for (const card of portfolioCards) { const tickers = []; let totalAllocation = 0; const tickerRows = card.querySelectorAll('.ticker-input-row'); for (const row of tickerRows) { const ticker = row.querySelector('.ticker-input').value.trim().toUpperCase(); const allocation = parseFloat(row.querySelector('.allocation-input').value); if (ticker && allocation > 0) { tickers.push({ symbol: ticker, allocation }); totalAllocation += allocation; } } if (Math.round(totalAllocation) !== 100) { throw new Error(`Allocations in "${card.querySelector('.portfolio-name-input').value}" must sum to 100%. Current: ${totalAllocation}%.`); } portfolios.push({ id: card.id, name: card.querySelector('.portfolio-name-input').value, tickers }); } return portfolios; }
    
    const proxies = ["https://corsproxy.io/?", "https://api.allorigins.win/raw?url="];
    async function fetchWithFallback(url) { for (const prefix of proxies) { try { const res = await fetch(prefix + encodeURIComponent(url)); if (!res.ok) throw new Error(`Proxy request failed: ${res.status}`); const data = await res.json(); if (data.chart.error) throw new Error(data.chart.error.message); if (!data.chart.result || data.chart.result.length === 0 || !data.chart.result[0].timestamp) { throw new Error('No data returned for ticker.'); } return data; } catch (e) { console.warn(`Proxy for ${url} failed: ${e.message}`); } } throw new Error(`All fetching attempts failed for ${url.split('?')[0].split('/').pop()}`); }
    async function fetchTickerData(ticker, startDate, endDate) { const startTimestamp = Math.floor(new Date(startDate).getTime() / 1000); const endTimestamp = Math.floor(new Date(endDate).getTime() / 1000); const url = `https://query1.finance.yahoo.com/v8/finance/chart/${ticker}?period1=${startTimestamp}&period2=${endTimestamp}&interval=1d&events=div`; const data = await fetchWithFallback(url); const result = data.chart.result[0]; const prices = {}; result.timestamp.forEach((ts, i) => { const date = new Date(ts * 1000).toISOString().split('T')[0]; if (result.indicators.quote[0].close[i] !== null) { prices[date] = result.indicators.quote[0].close[i]; } }); const dividends = {}; if (result.events && result.events.dividends) { Object.values(result.events.dividends).forEach(div => { const date = new Date(div.date * 1000).toISOString().split('T')[0]; dividends[date] = (dividends[date] || 0) + div.amount; }); } return { prices, dividends }; }

    function calculatePortfolioPerformance(portfolio, allData, config, benchmarkData = null) {
        const { initialInvestment, startDate, endDate, contributionAmount, contributionFrequency, rebalanceFrequency, reinvestDividends, riskFreeRate, dividendTaxRate, gainsTaxRate } = config;
        const tradingDays = Object.keys(allData[Object.keys(allData)[0]].prices).sort().filter(d => d >= startDate && d <= endDate);
        if (tradingDays.length === 0) throw new Error("No trading days found in the selected date range.");
        let totalContributions = initialInvestment; let cumulativeDividends = 0; const holdings = {}; let hprFactors = []; let valueAtStartOfPeriod = initialInvestment;
        const startingPriceDate = tradingDays[0]; let portfolioValue = initialInvestment;
        for (const { symbol, allocation } of portfolio.tickers) { if (!allData[symbol] || !allData[symbol].prices[startingPriceDate]) throw new Error(`Could not get starting price for ${symbol}.`); const startingPrice = allData[symbol].prices[startingPriceDate]; const valueStart = portfolioValue * (allocation / 100); holdings[symbol] = { shares: valueStart / startingPrice, data: allData[symbol], valueStart: valueStart, priceStart: startingPrice }; }
        holdings.CASH = { shares: 0 };
        let dailyValues = [{ date: tradingDays[0], value: portfolioValue }];
        let lastContributionMonth = -1, lastContributionQuarter = -1, lastContributionYear = -1;
        let lastRebalanceQuarter = -1, lastRebalanceYear = -1;
        let peakValue = portfolioValue, maxDrawdown = 0, bestYear = -Infinity, worstYear = Infinity;
        for (let i = 1; i < tradingDays.length; i++) {
            const day = tradingDays[i]; const prevDay = tradingDays[i-1]; const currentDate = new Date(day);
            portfolioValue = 0;
            for (const symbol in holdings) {
                if(symbol === 'CASH') continue;
                const price = holdings[symbol].data.prices[day] || holdings[symbol].data.prices[prevDay];
                if (holdings[symbol].data.dividends[day]) { const divAmount = holdings[symbol].shares * holdings[symbol].data.dividends[day]; cumulativeDividends += divAmount; const netDivAmount = divAmount * (1 - dividendTaxRate); if (reinvestDividends) { holdings[symbol].shares += netDivAmount / price; } else { holdings.CASH.shares += netDivAmount; } }
                portfolioValue += holdings[symbol].shares * price;
            }
            portfolioValue += holdings.CASH.shares;
            let contributedThisDay = false;
            const currentMonth = currentDate.getUTCMonth(); const currentQuarter = Math.floor(currentMonth / 3); const currentYear = currentDate.getUTCFullYear();
            if (contributionFrequency === 'monthly' && currentMonth !== lastContributionMonth) { contributedThisDay = true; lastContributionMonth = currentMonth; }
            if (contributionFrequency === 'quarterly' && currentQuarter !== lastContributionQuarter) { contributedThisDay = true; lastContributionQuarter = currentQuarter; }
            if (contributionFrequency === 'annually' && currentYear !== lastContributionYear) { contributedThisDay = true; lastContributionYear = currentYear; }
            if(contributedThisDay && contributionAmount > 0) {
                hprFactors.push(portfolioValue / valueAtStartOfPeriod);
                portfolioValue += contributionAmount; totalContributions += contributionAmount; valueAtStartOfPeriod = portfolioValue;
                for (const { symbol, allocation } of portfolio.tickers) { const price = holdings[symbol].data.prices[day]; holdings[symbol].shares += (contributionAmount * (allocation / 100)) / price; }
            }
            let rebalancedThisDay = false;
            if (rebalanceFrequency === 'quarterly' && currentQuarter !== lastRebalanceQuarter) { rebalancedThisDay = true; lastRebalanceQuarter = currentQuarter; }
            if (rebalanceFrequency === 'annually' && currentYear !== lastRebalanceYear) { rebalancedThisDay = true; lastRebalanceYear = currentYear; }
            if(rebalancedThisDay) {
                let tax = 0;
                if(gainsTaxRate > 0) {
                    let realizedGains = 0;
                    for (const { symbol, allocation } of portfolio.tickers) { const price = holdings[symbol].data.prices[day]; const currentValue = holdings[symbol].shares * price; const targetValue = portfolioValue * (allocation / 100); if (currentValue > targetValue) { realizedGains += (currentValue - targetValue) * 0.2; } }
                    tax = realizedGains * gainsTaxRate; portfolioValue -= tax;
                }
                for (const { symbol, allocation } of portfolio.tickers) { const price = holdings[symbol].data.prices[day]; holdings[symbol].shares = (portfolioValue * (allocation / 100)) / price; }
            }
            dailyValues.push({date: day, value: portfolioValue});
            if (portfolioValue > peakValue) peakValue = portfolioValue;
            const drawdown = (portfolioValue - peakValue) / peakValue;
            if (drawdown < maxDrawdown) maxDrawdown = drawdown;
            if (i >= 252) { const yearReturn = (portfolioValue / dailyValues[i-252].value) - 1; if (yearReturn > bestYear) bestYear = yearReturn; if (yearReturn < worstYear) worstYear = yearReturn; }
        }
        const endingValue = dailyValues[dailyValues.length - 1].value;
        hprFactors.push(endingValue / valueAtStartOfPeriod);
        const geometricMean = hprFactors.reduce((acc, val) => acc * val, 1);
        const twrr = Math.pow(geometricMean, 1 / hprFactors.length) -1;
        const annualizedTWRR = Math.pow(1 + twrr, 252 / (tradingDays.length / hprFactors.length)) - 1;
        const totalReturn = (endingValue / totalContributions) - 1;
        const dailyReturns = dailyValues.map((v, i) => i === 0 ? 0 : (v.value / dailyValues[i-1].value) - 1).slice(1);
        const meanReturn = dailyReturns.reduce((a, b) => a + b, 0) / dailyReturns.length;
        const stdDev = Math.sqrt(dailyReturns.map(r => Math.pow(r - meanReturn, 2)).reduce((a, b) => a + b, 0) / dailyReturns.length);
        const annualizedVolatility = stdDev * Math.sqrt(252);
        const sharpeRatio = (annualizedTWRR - riskFreeRate) / annualizedVolatility;
        const downsideReturns = dailyReturns.filter(r => r < 0);
        const downsideStdDev = Math.sqrt(downsideReturns.map(r => Math.pow(r - 0, 2)).reduce((a, b) => a + b, 0) / dailyReturns.length);
        const sortinoRatio = (annualizedTWRR - riskFreeRate) / (downsideStdDev * Math.sqrt(252));
        let beta = null, alpha = null, trackingError = null;
        if (benchmarkData && benchmarkData.dailyReturns.length === dailyReturns.length) {
            const benchmarkReturns = benchmarkData.dailyReturns;
            const cov = dailyReturns.reduce((sum, r_p, i) => sum + (r_p - meanReturn) * (benchmarkReturns[i] - benchmarkData.meanReturn), 0) / dailyReturns.length;
            beta = cov / benchmarkData.variance; alpha = annualizedTWRR - (riskFreeRate + beta * (benchmarkData.twrr - riskFreeRate));
            const returnDifferences = dailyReturns.map((r, i) => r - benchmarkReturns[i]);
            const stdDevDiff = Math.sqrt(returnDifferences.map(d => Math.pow(d - (returnDifferences.reduce((a,b)=>a+b,0)/returnDifferences.length),2)).reduce((a,b)=>a+b,0) / returnDifferences.length);
            trackingError = stdDevDiff * Math.sqrt(252);
        }
        const breakdown = portfolio.tickers ? portfolio.tickers.map(({ symbol, allocation }) => {
            const holding = holdings[symbol]; const priceEnd = holding.data.prices[tradingDays[tradingDays.length - 1]]; const valueEnd = holding.shares * priceEnd;
            return { symbol, allocation, valueStart: holding.valueStart, valueEnd, drift: (valueEnd / endingValue) * 100 - allocation };
        }) : null;
        return { portfolio, initialInvestment, totalContributions, endingValue, endingCash: holdings.CASH.shares, cumulativeDividends, twrr: annualizedTWRR, totalReturn, annualizedVolatility, sharpeRatio, sortinoRatio, maxDrawdown, beta, alpha, trackingError, bestYear, worstYear, dailyValues, breakdown };
    }
    
    function generateRandomReturn(mean, stdDev) { let u1=0, u2=0; while(u1===0) u1=Math.random(); while(u2===0) u2=Math.random(); const z0 = Math.sqrt(-2.0*Math.log(u1))*Math.cos(2.0*Math.PI*u2); return z0 * stdDev + mean; }
    
    function calculateMonteCarloProjection(portfolioResult, params, simulations) {
        const dividendYield = portfolioResult.cumulativeDividends / portfolioResult.endingValue / (portfolioResult.dailyValues.length / 252);
        const yearPaths = Array.from({ length: simulations }, () => ({ path: [], incomes: [] }));

        for (let i = 0; i < simulations; i++) {
            let value = portfolioResult.endingValue; yearPaths[i].path.push(value);
            let annualContribution = params.initialContribution * 12;

            for (let y = 0; y < params.accumulationYears; y++) {
                value += annualContribution;
                const randomReturn = generateRandomReturn(portfolioResult.twrr, portfolioResult.annualizedVolatility);
                value *= (1 + randomReturn);
                annualContribution *= (1 + params.contributionIncrease);
                yearPaths[i].path.push(value);
            }
            
            if (params.goal === 'retire') {
                for (let y = 0; y < params.decumulationYears; y++) {
                    const annualDividends = value * dividendYield;
                    let withdrawalAmount = 0, reinvestment = annualDividends;
                    if (params.withdrawalStrategy === 'dividends') { withdrawalAmount = annualDividends; reinvestment = 0; }
                    else if (params.withdrawalStrategy === 'percentage') { withdrawalAmount = value * params.withdrawalRate; reinvestment = Math.max(0, annualDividends - withdrawalAmount); }
                    else if (params.withdrawalStrategy === 'fixed_amount') { withdrawalAmount = params.withdrawalAmount; reinvestment = Math.max(0, annualDividends - withdrawalAmount); }
                    value -= withdrawalAmount; value += reinvestment;
                    const principalReturn = (value - reinvestment) * generateRandomReturn(portfolioResult.twrr, portfolioResult.annualizedVolatility);
                    value += principalReturn;
                    yearPaths[i].incomes.push(withdrawalAmount);
                    yearPaths[i].path.push(value < 0 ? 0 : value);
                }
            }
        }

        const getPercentilePath = (percentile, key) => {
            const path = [];
            const totalYears = params.accumulationYears + (params.goal === 'retire' ? params.decumulationYears : 0);
            for (let y = 0; y <= totalYears; y++) {
                const yearValues = yearPaths.map(p => p[key][y]).sort((a,b) => a - b);
                path.push(yearValues[Math.floor(simulations * percentile)]);
            }
            return path;
        };
        const getPercentileIncome = (percentile) => {
            if (params.goal !== 'retire' || params.decumulationYears === 0) return 0;
            const avgIncomes = yearPaths.map(p => p.incomes.length ? p.incomes.reduce((a,b) => a+b, 0) / p.incomes.length : 0);
            avgIncomes.sort((a,b) => a-b);
            return avgIncomes[Math.floor(simulations * percentile)];
        };

        const medianPath = getPercentilePath(0.5, 'path');
        return {
            medianPath, goodPath: getPercentilePath(0.9, 'path'), poorPath: getPercentilePath(0.1, 'path'),
            valueAtRetirement: medianPath[params.accumulationYears],
            medianIncome: getPercentileIncome(0.5),
            finalValue: medianPath[medianPath.length - 1],
        };
    }
    
    function formatNumber(num, type, decimals = 2) {
        if (typeof num !== 'number' || isNaN(num)) return 'N/A';
        if (type === 'currency') return '$' + num.toLocaleString('en-US', { minimumFractionDigits: decimals, maximumFractionDigits: decimals });
        if (type === 'percent') return (num * 100).toFixed(decimals) + ' %';
        return num.toFixed(decimals);
    }
    
    function createHelpTooltip(text) {
        return `<span class="help-icon" data-tooltip="${text.replace(/"/g, '&quot;')}">?</span>`;
    }

    function renderHistoricalResults(results) {
        primaryBenchmarkTicker = document.getElementById('benchmark1').value.trim().toUpperCase() || 'SPY';
        const names = results.map(r => r.portfolio.name);
        const overviewMetrics = [
            { label: 'Ending Value', key: 'endingValue', type: 'currency', help: 'The final total value of the portfolio at the end of the backtest period.' },
            { label: 'Total Return', key: 'totalReturn', type: 'percent', help: 'The total percentage gain or loss of the portfolio, based on the total contributions made.' }, 
            { label: 'TWRR (CAGR)', key: 'twrr', type: 'percent', help: 'Time-Weighted Rate of Return (or Compound Annual Growth Rate). This measures the true growth rate of your investment, ignoring the effects of your contributions. It is the best metric for comparing different strategies.' }
        ];
        const riskMetrics = [
            { label: 'Annualized Volatility', key: 'annualizedVolatility', type: 'percent', help: "Measures how much the portfolio's value swings up and down. Higher numbers mean a riskier, more 'bumpy' ride." },
            { label: 'Sharpe Ratio', key: 'sharpeRatio', type: 'number', help: 'Measures how much return you get for the amount of risk you take. A higher number is better.' },
            { label: 'Max Drawdown', key: 'maxDrawdown', type: 'percent', help: 'The largest single drop the portfolio experienced from its peak value during the backtest. It is a key measure of downside risk.' },
            { label: `Beta (vs. ${primaryBenchmarkTicker})`, key: 'beta', type: 'number', help: `Measures the portfolio's volatility relative to the benchmark (${primaryBenchmarkTicker}). A Beta of 1.1 means it's 10% more volatile than the benchmark.` },
            { label: `Alpha (vs. ${primaryBenchmarkTicker})`, key: 'alpha', type: 'percent', help: `Measures the portfolio's ability to outperform the market. A positive Alpha means it performed better than its benchmark, considering the risk it took.` }
        ];
        let overviewHTML = `<h3>Historical Overview</h3><div class="table-container"><table><thead><tr><th>Metric</th>`;
        names.forEach(name => overviewHTML += `<th>${name}</th>`); overviewHTML += `</tr></thead><tbody>`;
        overviewMetrics.forEach(m => { overviewHTML += `<tr><td>${m.label} ${createHelpTooltip(m.help)}</td>`; results.forEach(r => { overviewHTML += `<td>${formatNumber(r[m.key], m.type)}</td>`; }); overviewHTML += `</tr>`; });
        overviewHTML += `</tbody></table></div>`;
        
        let riskHTML = `<h3>Risk & Exposure</h3><div class="table-container"><table><thead><tr><th>Metric</th>`;
        names.forEach(name => riskHTML += `<th>${name}</th>`); riskHTML += `</tr></thead><tbody>`;
        riskMetrics.forEach(m => {
            riskHTML += `<tr><td>${m.label} ${createHelpTooltip(m.help)}</td>`;
            results.forEach(r => { riskHTML += `<td class="${r[m.key] < 0 ? 'negative' : ''}">${formatNumber(r[m.key], m.type, 2)}</td>`; });
            riskHTML += `</tr>`;
        });
        riskHTML += `</tbody></table></div>`;
        resultsArea.innerHTML = `<h2>3. Historical Backtest Results</h2>` + overviewHTML + riskHTML;
    }
    
    function renderProjectionChart(historicalData, projectionData, params) {
        const ctx = document.getElementById('projection-chart').getContext('2d'); if (projectionChartInstance) { projectionChartInstance.destroy(); }
        const colors = ['#007aff', '#34c759', '#ff9500', '#af52de', '#ff3b30', '#5856d6'];
        const datasets = [];
        historicalData.forEach((p, i) => { datasets.push({ label: `${p.name} (Historical)`, data: p.dailyValues.map(d => ({x: new Date(d.date).valueOf(), y: d.value})), borderColor: colors[i % colors.length], borderWidth: 2.5, pointRadius: 0, tension: 0.1 }); });
        projectionData.forEach((p, i) => {
            const historicalEnd = historicalData.find(h => h.portfolio.name === p.name).dailyValues.slice(-1)[0];
            const projectionStartDate = new Date(historicalEnd.date);
            const getPath = (pathData) => pathData.map((val, j) => ({x: new Date(projectionStartDate.getFullYear()+j, projectionStartDate.getMonth(), projectionStartDate.getDate()).valueOf(), y: val}));
            datasets.push({ label: `${p.name} (Likely Future)`, data: getPath(p.monteCarlo.medianPath), borderColor: colors[i % colors.length], borderDash: [6, 3], borderWidth: 2, pointRadius: 0, tension: 0.4, fill: false });
            datasets.push({ label: `${p.name} (Range of Outcomes)`, data: getPath(p.monteCarlo.poorPath).concat(getPath(p.monteCarlo.goodPath).reverse()), borderColor: 'transparent', borderWidth: 0, pointRadius: 0, backgroundColor: colors[i % colors.length] + '1A', fill: 'origin'});
        });
        projectionChartInstance = new Chart(ctx, { type: 'line', data: { datasets: datasets }, options: { plugins: { legend: { labels: { filter: item => !item.text.includes('(Range of Outcomes)') } }, tooltip: { mode: 'index', intersect: false, callbacks: { title: function(context) { return new Date(context[0].parsed.x).toLocaleDateString(); }, label: function(context) { const label = context.dataset.label || ''; const value = formatNumber(context.parsed.y, 'currency', 0); return `${label}: ${value}`; } } } }, scales: { x: { type: 'time', time: { unit: 'year' } }, y: { ticks: { callback: function(value) { return formatNumber(value, 'currency', 0); } } } } } });
    }
    
    function renderProjectionResults(projectionResults, params) {
        const names = projectionResults.map(r => r.name);
        let mcHTML = '';
         if (params.goal === 'retire') {
            mcHTML += `<h3>Your Retirement Projection</h3><div class="table-container"><table><thead><tr><th>Key Milestone</th>`;
            names.forEach(name => mcHTML += `<th>${name}</th>`); mcHTML += `</tr></thead><tbody>`;
            mcHTML += `<tr><td>Value at Retirement<span class="outcome-explanation">Likely value at age ${params.retirementAge}.</span></td>`;
            projectionResults.forEach(r => mcHTML += `<td>${formatNumber(r.monteCarlo.valueAtRetirement, 'currency', 0)}</td>`); mcHTML += `</tr>`;
            mcHTML += `<tr><td>Average Annual Income<span class="outcome-explanation">Likely income during your retirement, in today's money.</span></td>`;
            projectionResults.forEach(r => mcHTML += `<td>${formatNumber(r.monteCarlo.medianIncome / Math.pow(1 + params.inflationRate, params.accumulationYears), 'currency', 0)} / year</td>`); mcHTML += `</tr>`;
            mcHTML += `<tr><td>Final Portfolio Value<span class="outcome-explanation">Likely value left at age ${params.finalAge}.</span></td>`;
            projectionResults.forEach(r => mcHTML += `<td>${formatNumber(r.monteCarlo.finalValue, 'currency', 0)}</td>`); mcHTML += `</tr>`;
        } else {
            mcHTML += `<h3>Potential Future Outcomes (${params.accumulationYears}-Year Projection)</h3><div class="table-container"><table><thead><tr><th>Scenario</th>`;
            names.forEach(name => mcHTML += `<th>${name}</th>`); mcHTML += `</tr></thead><tbody>`;
            mcHTML += `<tr><td>Optimistic Scenario<span class="outcome-explanation">A great outcome (top 10% chance).</span></td>`;
            projectionResults.forEach(r => { mcHTML += `<td>${formatNumber(r.monteCarlo.goodPath.slice(-1)[0], 'currency', 0)}</td>`; }); mcHTML += `</tr>`;
            mcHTML += `<tr><td>Likely Scenario<span class="outcome-explanation">The middle-of-the-road outcome.</span></td>`;
            projectionResults.forEach(r => { mcHTML += `<td>${formatNumber(r.monteCarlo.medianPath.slice(-1)[0], 'currency', 0)}</td>`; }); mcHTML += `</tr>`;
            mcHTML += `<tr><td>Pessimistic Scenario<span class="outcome-explanation">An unlucky outcome (bottom 10% chance).</span></td>`;
            projectionResults.forEach(r => { mcHTML += `<td>${formatNumber(r.monteCarlo.poorPath.slice(-1)[0], 'currency', 0)}</td>`; }); mcHTML += `</tr>`;
            mcHTML += `<tr style="background-color: #f8f9fa;"><td><strong>Value in Today's Money</strong><span class="outcome-explanation">The likely outcome, adjusted for inflation.</span></td>`;
            projectionResults.forEach(r => { const realValue = r.monteCarlo.medianPath.slice(-1)[0] / Math.pow(1 + params.inflationRate, params.accumulationYears); mcHTML += `<td><strong>${formatNumber(realValue, 'currency', 0)}</strong></td>`; }); mcHTML += `</tr>`;
        }
        mcHTML += `</tbody></table></div>`;
        projectionsResultsArea.innerHTML = mcHTML;
    }

    async function runBacktest() {
        runBtn.disabled = true; loader.style.display = 'block'; errorContainer.textContent = '';
        resultsArea.classList.add('hidden'); projectionsArea.classList.add('hidden');
        projectionsResultsArea.classList.add('hidden'); projectionChartContainer.classList.add('hidden');
        if (projectionChartInstance) { projectionChartInstance.destroy(); projectionChartInstance = null; }
        try {
            const config = { initialInvestment: parseFloat(document.getElementById('initial-investment').value), startDate: document.getElementById('start-date').value, endDate: document.getElementById('end-date').value, contributionAmount: parseFloat(document.getElementById('contribution-amount').value), contributionFrequency: document.getElementById('contribution-frequency').value, rebalanceFrequency: document.getElementById('rebalance-frequency').value, reinvestDividends: document.getElementById('reinvest-dividends').value === 'true', riskFreeRate: parseFloat(document.getElementById('risk-free-rate').value) / 100, dividendTaxRate: parseFloat(document.getElementById('dividend-tax-rate').value) / 100, gainsTaxRate: parseFloat(document.getElementById('gains-tax-rate').value) / 100 };
            primaryBenchmarkTicker = document.getElementById('benchmark1').value.trim().toUpperCase() || 'SPY';
            const secondaryBenchmarkTicker = document.getElementById('benchmark2').value.trim().toUpperCase();
            const benchmarks = [...new Set([primaryBenchmarkTicker, secondaryBenchmarkTicker].filter(b => b))];
            const portfolios = parsePortfolios();
            if (portfolios.length === 0 && benchmarks.length === 0) { throw new Error("Please configure at least one portfolio or benchmark."); }
            const uniqueTickers = Array.from(new Set([...benchmarks, ...portfolios.flatMap(p => p.tickers.map(t => t.symbol))]));
            const settledResults = await Promise.allSettled(uniqueTickers.map(ticker => fetchTickerData(ticker, config.startDate, config.endDate)));
            const allData = {}; const failedTickers = [];
            settledResults.forEach((result, i) => { const ticker = uniqueTickers[i]; if (result.status === 'fulfilled') { allData[ticker] = result.value; } else { failedTickers.push(ticker); } });
            if (failedTickers.length > 0) { throw new Error(`Failed to fetch data for: ${failedTickers.join(', ')}.`); }
            const benchmarkResults = {};
            if (primaryBenchmarkTicker) {
                const primaryBenchmarkResult = calculatePortfolioPerformance({ name: primaryBenchmarkTicker, tickers: [{ symbol: primaryBenchmarkTicker, allocation: 100 }]}, allData, config);
                const dailyReturns = primaryBenchmarkResult.dailyValues.map((v, i) => i === 0 ? 0 : (v.value / primaryBenchmarkResult.dailyValues[i-1].value) - 1).slice(1);
                const meanReturn = dailyReturns.reduce((a, b) => a + b, 0) / dailyReturns.length;
                benchmarkResults[primaryBenchmarkTicker] = { ...primaryBenchmarkResult, dailyReturns, meanReturn, variance: dailyReturns.map(r => Math.pow(r - meanReturn, 2)).reduce((a, b) => a + b, 0) / dailyReturns.length };
            }
            const portfolioResults = portfolios.map(p => calculatePortfolioPerformance(p, allData, config, benchmarkResults[primaryBenchmarkTicker]));
            if (secondaryBenchmarkTicker && secondaryBenchmarkTicker !== primaryBenchmarkTicker) {
                benchmarkResults[secondaryBenchmarkTicker] = calculatePortfolioPerformance({ name: secondaryBenchmarkTicker, tickers: [{ symbol: secondaryBenchmarkTicker, allocation: 100 }]}, allData, config, benchmarkResults[primaryBenchmarkTicker]);
            }
            historicalResults = [...portfolioResults, ...Object.values(benchmarkResults).filter(b => b)];
            renderHistoricalResults(historicalResults);
            resultsArea.classList.remove('hidden'); projectionsArea.classList.remove('hidden');
            resultsArea.scrollIntoView({ behavior: 'smooth' });
        } catch (error) { errorContainer.textContent = `Error: ${error.message}`; } finally { runBtn.disabled = false; loader.style.display = 'none'; }
    }
    
    function runProjections() {
        debugContainer.innerHTML = '<h4>Projection Debug Log:</h4>'; 
        logToPage('`runProjections` function called.');
        try {
            if (historicalResults.length === 0) { throw new Error('Historical backtest results are not available.'); }
            let params = { goal: projectionGoalSelect.value, simulations: 5000 };
            if (params.goal === 'grow') {
                params.accumulationYears = parseInt(document.getElementById('grow-projection-period').value);
                params.simulations = parseInt(document.getElementById('grow-sim-quality').value);
                params.inflationRate = parseFloat(document.getElementById('grow-inflation-rate').value) / 100;
                params.contributionIncrease = parseFloat(document.getElementById('grow-contribution-increase').value) / 100;
                params.initialContribution = document.getElementById('contribution-frequency').value === 'none' ? 0 : parseFloat(document.getElementById('contribution-amount').value);
            } else {
                const currentAge = parseInt(document.getElementById('current-age').value);
                const retirementAge = parseInt(document.getElementById('retirement-age').value);
                const finalAge = parseInt(document.getElementById('final-age').value);
                params.accumulationYears = Math.max(0, retirementAge - currentAge);
                params.decumulationYears = Math.max(0, finalAge - retirementAge);
                params.retirementAge = retirementAge; params.finalAge = finalAge;
                params.inflationRate = parseFloat(document.getElementById('retire-inflation-rate').value) / 100;
                params.contributionIncrease = parseFloat(document.getElementById('retire-contribution-increase').value) / 100;
                params.initialContribution = document.getElementById('contribution-frequency').value === 'none' ? 0 : parseFloat(document.getElementById('contribution-amount').value);
                params.withdrawalStrategy = withdrawalStrategySelect.value;
                if (params.withdrawalStrategy === 'fixed_amount') { params.withdrawalAmount = parseFloat(document.getElementById('annual-withdrawal-amount').value); }
                else if (params.withdrawalStrategy === 'percentage') { params.withdrawalRate = parseFloat(document.getElementById('annual-withdrawal-rate').value) / 100; }
            }
            logToPage('Starting calculations with params: ' + JSON.stringify(params));
            const projectionResults = historicalResults.map(p => ({ name: p.portfolio.name, monteCarlo: calculateMonteCarloProjection(p, params, params.simulations) }));
            logToPage('Calculations finished.');
            logToPage('Rendering results and chart...');
            renderProjectionResults(projectionResults, params);
            renderProjectionChart(historicalResults, projectionResults, params);
            projectionsResultsArea.classList.remove('hidden');
            projectionChartContainer.classList.remove('hidden');
            projectionsResultsArea.scrollIntoView({ behavior: 'smooth' });
            logToPage('Projections successfully rendered.');
        } catch (error) {
            logToPage(`FATAL ERROR: ${error.message}`, true);
            console.error(error);
        }
    }
    
    addPortfolioBtn.addEventListener('click', addPortfolio);
    runBtn.addEventListener('click', runBacktest);
    runProjectionsBtn.addEventListener('click', runProjections);
    addPortfolio();
});
</script>
</body>
</html>
